generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl         = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
  shadowDatabaseUrl = env("POSTGRES_URL_NON_POOLING") // used for migrations
}

model User {
  id               Int             @id @default(autoincrement())
  name             String          @db.VarChar(255)
  password         String          @db.VarChar(255)
  email            String          @unique @db.VarChar(255)
  verificationCode String?         @unique @db.VarChar(255)
  isVerified       Boolean         @default(false)
  currentChallenge String?         @unique @db.VarChar(255)
  authenticators   Authenticator[]
}

model Authenticator {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId Int

  //   // SQL: Encode to base64url then store as `TEXT`. Index this column
  // credentialID: Uint8Array;
  credentialID String @unique @db.Text

  // // SQL: Store raw bytes as `BYTEA`/`BLOB`/etc...
  // credentialPublicKey: Uint8Array;
  credentialPublicKey Bytes @db.ByteA

  // // SQL: Consider `BIGINT` since some authenticators return atomic timestamps as counters
  // counter: number;
  counter BigInt

  // // SQL: `VARCHAR(32)` or similar, longest possible value is currently 12 characters
  // // Ex: 'singleDevice' | 'multiDevice'
  // credentialDeviceType: CredentialDeviceType;
  credentialDeviceType String @db.VarChar(32)

  // // SQL: `BOOL` or whatever similar type is supported
  // credentialBackedUp: boolean;
  credentialBackedUp Boolean

  // // SQL: `VARCHAR(255)` and store string array as a CSV string
  // // Ex: ['usb' | 'ble' | 'nfc' | 'internal']
  // transports?: AuthenticatorTransport[];
  transports String? @db.VarChar(255)
}
